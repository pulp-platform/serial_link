{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Serial Link","text":"<p>The serial link is a simple all-digital Double-Data-Rate (DDR) link with a source-synchronous interface. The link is scalable and can be used for high-bandwidth low latency applications like Die2Die communication as well as lower demanding tasks like binary preloading. The link has an AXI4 interface and implements Network, Data Link and Physical layer. The serial link is part of the PULP (Parallel Ultra-Low Power) Platform and is being used in various chip tapeouts e.g. Snitch based Systems</p>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>The serial link implements the 3 lowest layers of the OSI reference model: * Network Layer: AXI requests and the responses are serialized and translated to an AXI-Stream interface * Data Link Layer: Splits the payload of the AXI stream into multiple packets which are distributed over the physical channels. A Channel Allocator reshuffles the packets and is able to recover defects of physical channels. It is able to apply back-pressure with a credit-based flow control mechanism. It also synchronizes the packets of multiple channels. * Physical Layer: Parametrizable number of channels and wires per channel. Each TX channel forwards its own source-synchronous clock which is a divided clock of the system clock. The RX channels samples the data with the received clock and has a CDC to synchronize to the local system clock.</p>"},{"location":"#license","title":"License","text":"<p>The Serial Link is released under Solderpad v0.51 (SHL-0.51) see <code>LICENSE</code>:</p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#dependencies","title":"Dependencies","text":"<p>The link uses bender to manage its dependencies and to automatically generate compilation scripts. Further <code>Python &gt;= 3.8</code> is required with the packages listed in <code>requirements.txt</code>. Currently, we do not provide any open-source simulation setup. Internally, the Serial Link was tested using QuestaSim.</p>"},{"location":"#simulation","title":"Simulation","text":"<p>The Serial Link can be simulated in QuestaSim with the following steps:</p> <pre><code># To compile the link, run the following command:\nmake all\n# Run the simulation. This will start the simulation in batch mode.\nmake run\n# To open it in the GUI mode, run the following command:\n# This command will also add all interesting waves to the wave window.\nmake run GUI=true\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>The link can be parametrized with arbitrary AXI interfaces resp. structs (<code>axi_req_t</code>, <code>axi_rsp_t</code>). Further, the number of Channels number of Lanes per Channel is configurable in <code>serial_link_pkg.sv</code>.</p>"},{"location":"#single-channel","title":"Single-Channel","text":"<p>For simple use cases with lower low bandwidth requirements (e.g. binary preloading), it is recommended to use a single-channel configuration. Single-channel configurations come with less overhead for channel synchronization and fault detection.</p>"},{"location":"#multi-channel","title":"Multi-Channel","text":"<p>For use cases that require a higher bandwidth (e.g. Die2Die communication), a multi-channel configuration is recommended. In multi-channel configurations, each channel has its own source-synchronous forwarded clock and the channels are synchronized on the receiver side again. Further, a channel allocator handles faulty channels by redistributing the packets to functional channels. The detection of faulty channels can be done entirely in SW with a special Raw Mode that decouples the link from the AXI interface and allows full controllability and observability of independent channels.</p>"},{"location":"#configuration-registers","title":"Configuration Registers","text":"<p>Single-channel and Multi-channels currently use different configuration register files because the multi-channel configuration requires additional registers for the channel allocator etc. The registers are generated with the reggen. The config files for single-channel (<code>serial_link_single_channel.hjson</code>) and multi-channel (<code>serial_link.hjson</code>) can be found in the <code>src/regs</code> folder and can be regenerated with the following command:</p> <pre><code>make update-regs\n</code></pre>"},{"location":"channel_allocator/","title":"Channel allocator","text":""},{"location":"channel_allocator/#channel-allocator","title":"Channel Allocator","text":"<p>The Channel Allocator is a module of the Serial Link between the Data Link Layer and the Physical Layer that handles faulty channels. It is able to redistribute packets assigned to faulty channels to working channel. Further, it also takes care of the synchronization of the RX channels.</p>"},{"location":"channel_allocator/#calibration","title":"Calibration","text":"<p>The Channel Allocator needs to be configured with the active/working RX and TX channels. To this end, the Serial Link needs to be calibrated initially. The calibration is done by configuring the Serial Link in the Raw Mode where a mask of working resp. faulty channels is extracted and which is used to configure the Channel Allocator</p>"},{"location":"channel_allocator/#operating-modes","title":"Operating modes","text":"<p>The Channel Allocator can be bypassed by SW configuration e.g. this is required during the Raw Mode.</p>"},{"location":"channel_allocator/#rx-synchronization","title":"RX Synchronization","text":"<p>The Data Link layer splits up a AXI Stream payload to smaller packets that are sent over different channels. On the receiving side those packets need to be assembled again to a AXI Stream payload. Since different channels might have different delays, the packets of the channels need to be synchronized, which is done by the Channel Allocator</p>"},{"location":"constraints/","title":"Constraints","text":""},{"location":"constraints/#constraints","title":"Constraints","text":"<p>The Serial Link has Double-Data-Rate (DDR) and a source-synchronous interface with generated clocks which makes the constraints quite involved. The constraints were by the Source-Synchronous DDR IO Timing Constraints Cookbook by David Olsen, Altera Corporation, 2010.</p>"},{"location":"constraints/#generated-and-virtual-clocks","title":"Generated and Virtual Clocks","text":"<p>The data is synchronous to a zero phase shifted clock. This clock needs to be defined as virtual since it does not exist at the receiver side. The actual clock is shifted with respect to the virtual clock by -90 or +270 degrees (resp. shifted by +90 degrees and then inverted). The clocks on RX side are generated the following way:</p> <pre><code># Rising edge is at 270 degree, falling edge at 450 (resp. 60) degrees\nset edge_list [list [expr $T_FWD_CLK / 4 * 3] [expr $T_FWD_CLK / 4 * 5]]\ncreate_clock -name vir_clk_ddr_in -period $T_FWD_CLK\ncreate_clock -name clk_ddr_in -period $T_FWD_CLK -waveform $edge_list [get_ports ddr_rcv_clk_i]\n</code></pre> <p>The clocks on TX side are generated the following way:</p> <pre><code># The data launching clock with 0 degree clock phase\ncreate_generated_clock -name clk_slow -source clk_i -divide_by $FWD_CLK_DIV \\\n    [get_pins -hierarchical clk_slow_reg/Q]\n\n# this is the \"forwarded clock\", we are assuming it is shifted by -90 or +270 degrees (or +90 degrees and inverted)\nset edge_list [list [expr 1 + $FWD_CLK_DIV / 2 * 3] [expr 1 + $FWD_CLK_DIV / 2 * 5] [expr 1 + $FWD_CLK_DIV / 2 * 7]]\ncreate_generated_clock -name clk_ddr_out -source clk_i -edges $edge_list \\[get_pins -hierarchical ddr_rcv_clk_o_reg/Q]\n</code></pre>"},{"location":"constraints/#false-paths","title":"False paths","text":"<p>DDR has some timing arcs that needs to be removed. See an illustration below</p> <p></p> <p>There is no conventional setup relationship (rise to rise and fall to fall). We leave only the inter-clock launching edge to capturing edge timing arcs (rise to fall and fall to rise)</p> <pre><code># Input\nset_false_path -setup -rise_from [get_clocks vir_clk_ddr_in] -rise_to [get_clocks clk_ddr_in]\nset_false_path -setup -fall_from [get_clocks vir_clk_ddr_in] -fall_to [get_clocks clk_ddr_in]\n# Output\nset_false_path -setup -rise_from [get_clocks clk_slow] -rise_to [get_clocks clk_ddr_out]\nset_false_path -setup -fall_from [get_clocks clk_slow] -fall_to [get_clocks clk_ddr_out]\n</code></pre> <p>There is no actual hold relationship from non consecutive launching to capturing edges; data change at every edge, therefore we can remove the timing arcs that do not go from the current edge to the previous one (rise to fall and fall to rise). We leave only inter-clocks hold relationship (fall to fall and rise to rise)</p> <pre><code># Input\nset_false_path -hold  -rise_from [get_clocks vir_clk_ddr_in] -fall_to [get_clocks clk_ddr_in]\nset_false_path -hold  -fall_from [get_clocks vir_clk_ddr_in] -rise_to [get_clocks clk_ddr_in]\n# Output\nset_false_path -hold  -rise_from [get_clocks clk_slow] -fall_to [get_clocks clk_ddr_out]\nset_false_path -hold  -fall_from [get_clocks clk_slow] -rise_to [get_clocks clk_ddr_out]\n</code></pre> <p>There is on last false path from the system/fll clock to the forwarded clock</p> <pre><code>set_false_path -from [get_pins my_system_clock_pin] -to [get_ports my_clk_ddr_out_port]\n</code></pre>"},{"location":"constraints/#io-delays","title":"I/O Delays","text":"<p>The input and ouput delay is constrained in a way that it arrives in between a window around the clock edge of the virtual (0 degree) clock for the input side resp. the forwarded clock (90 degree) for the output side.</p> <pre><code># Window has a margin on both side of 5% of a quarter of the clock period\nset MARGIN              [expr $T_FWD_CLK / 4 * 0.05]\n\n# Input delays\nset_input_delay -max -clock [get_clocks vir_clk_ddr_in] [expr $MARGIN] [get_ports ddr_i]\nset_input_delay -add_delay -min -clock [get_clocks vir_clk_ddr_in] [expr -$MARGIN] [get_ports ddr_i]\nset_input_delay -add_delay -max -clock_fall -clock [get_clocks vir_clk_ddr_in] [expr $MARGIN] [get_ports ddr_i]\nset_input_delay -add_delay -min -clock_fall -clock [get_clocks vir_clk_ddr_in] [expr -$MARGIN] [get_ports ddr_i]\n\n# Output delays\nset_output_delay -max -clock [get_clocks clk_ddr_out] [expr $T_FWD_CLK / 4 + $MARGIN] -reference_pin [get_ports ddr_rcv_clk_o] [get_ports ddr_o]\nset_output_delay -add_delay -min -clock [get_clocks clk_ddr_out] [expr $T_FWD_CLK / 4 - $MARGIN] -reference_pin [get_ports ddr_rcv_clk_o] [get_ports ddr_o]\nset_output_delay -add_delay -max -clock_fall -clock [get_clocks clk_ddr_out] [expr $T_FWD_CLK / 4 + $MARGIN] -reference_pin [get_ports ddr_rcv_clk_o] [get_ports ddr_o]\nset_output_delay -add_delay -min -clock_fall -clock [get_clocks clk_ddr_out] [expr $T_FWD_CLK / 4 - $MARGIN] -reference_pin [get_ports ddr_rcv_clk_o] [get_ports ddr_o]\n</code></pre>"},{"location":"constraints/#clock-domain-crossings","title":"Clock Domain Crossings","text":"<p>Every RX channel has a <code>cdc_fifo_gray</code> module of the <code>common_cells</code> libary which needs to be constrained. Readers are refered to the documention of this module. Further, there is a <code>cdc_2phase</code> module to synchronize the <code>REG_BUS</code> which is connected to the configuration registers running with the system clock.</p>"},{"location":"data_link_layer/","title":"Data link layer","text":""},{"location":"data_link_layer/#data-link-layer","title":"Data Link Layer","text":"<p>The Data Link layer doesn't play a big role in the Serial Link. It mainly acts as an adapter between the Network Layer and the Channel Allocator. In the network layer the AXI Stream payload is split into multiple channel-sized packets which can then be reshuffled in the Channel Allocator which is a separate module. Further it also implements a Raw-Mode which is described in more detail below.</p>"},{"location":"data_link_layer/#raw-mode","title":"Raw Mode","text":"<p>To calibrate and bring-up the Serial Link in the beginning, it is advantageous to be able to control channels independently and decouple the AXI interface. This feature is implemented in the Serial Link as the Raw Mode and it allows to detect if some of the channels have faults. The Raw Mode is fully SW controllable and can be configured throught the configuration registers which are mapped in to the configuration address space of the Serial Link. The logic includes a FIFO which can be filled with a sequence of calibration patterns which can be defined at runtime. An output mask can be configured to select the channels which should send out a the sequence of calibration patterns to the other side e.g. single-channel, multi-channel or broadcasting of patterns is possible. On the receiving side, each channel stores the sequence of patterns in a FIFO where it can be subsequently read out.</p>"},{"location":"network_layer/","title":"Network layer","text":""},{"location":"network_layer/#network-layer","title":"Network layer","text":"<p>The Network layer has a duplex (Master/Slave) AXI4 interface and translates AXI4 transactions to AXI4-Streams and vice-versa. On the input side, it implements an arbiter to select an AXI4 beat (AW, W, B, AR, R) which is then forward to the Data Link Layer. The arbitration is implemented in a way that prevents deadlock caused by the AXI4 to AXI4-Stream protocol conversion. A block diagram is shown below</p> <p></p>"},{"location":"network_layer/#packeting","title":"Packeting","text":"<p>The payload that is sent to the data link layer contains the AXI beats (AW, W, B, AR, R), a header to encode type of AXI beat and credits for the flow control. Since B responses are very small, they are packeted together with one of the other AXI channels to prevent BW degredation.</p>"},{"location":"network_layer/#arbitration","title":"Arbitration","text":"<p>The arbitration of AXI requests and respones have the following priorities: 1. B responses are always granted as they can be sent along other req/rsp 2. AR/AW beats have priority, but only one AR/AW can be in flight each. Otherwise deadlocks can occur if the AR/AW beats have consumed all the credits but the transaction has not been terminated. 3. R/W beats have lowest priority</p> <p>Further, W requests are not granted before the corresponding AW request. Arbitration between AR/AW and R/W beats are implemented as psuedo Round-Robin to prevent starvation of one channel.</p>"},{"location":"network_layer/#flow-control","title":"Flow control","text":"<p>Each time a new payload is granted, a credit counter is decremented. This allows to generate back-pressure to the AXI interface. Otherwise the FIFOs on the receiving side can potentially overflow. The credit counters are incremented once the receiving side sends back the credits together with a request/response. There is a mechanism to force the network layer to send out packets with an empty payload but with credits. This prevents deadlock situations where the communication is very onsided e.g. long write bursts. Technically, flow-control would be part of the Data Link layer. However, the implementation is simpler in the <code>serial_link_network</code> module since there are simple handshaking interfaces.</p>"},{"location":"physical_layer/","title":"Physical layer","text":""},{"location":"physical_layer/#physical-layer","title":"Physical Layer","text":"<p>The Physical Layer of the Serial Link has multiple channels where each channel has a configurable number of Lanes and its own source-synchronous clock. The physical protocol is essentially based on oversampling which is achieved by sending the data with a generated divided clock. The data is sent with Double-Data-Rate (DDR).</p>"},{"location":"physical_layer/#protocol","title":"Protocol","text":"<p>The physical protocol of the Serial Link is shown below</p> <p></p> <p>The data is sent synchronous to a generated divided clock, which is generated by a simple and SW configurable clock divider. Further, a clock is forwarded together with the data to sample the data on the receiving side. This forwarded source-synchronous clock typically has a phase shift of 90 degrees, such that sampling occurs when the eye opening is at a maximum. The exact phase shift is configurable i.e. the negative and positive edge of the forwarded clock can be configured independently by SW.</p>"},{"location":"physical_layer/#tx-channel","title":"TX Channel","text":"<p>The implementation of a TX channel is pretty simple. It contains a clock a configurable clock divider for generating the divided data and the forwarded clock. Since the Serial Link is Double-Data-Rate (DDR), the TX channel just multiplexes the output based on the data clock. To signal when actual data is being sent the TX channel clock-gates the forwarded clock i.e. in idle operating mode the forwarded clock is tied to <code>'1</code>.</p>"},{"location":"physical_layer/#rx-channel","title":"RX Channel","text":"<p>On the RX side a CDC FIFO takes care of synchronizing the data to the system clock. DDR is handled by sampling the first part of data on negedge-triggered FF and sampling the second part directly with the CDC Fifo which is positive-edge triggered.</p>"}]}